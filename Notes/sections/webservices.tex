\section{Web Services}
Web services are the current evolution of middleware technology. Basically are offered in a way over Internet. In other words, a web service is a software functionality exposed over the Internet. This means that any piece of code and any application component deployed on a system can be transformed into a network-available service. The main difference between middleware and web services, is Internet, because the latter emerged at the beginning of 2000 (when vendors invented new technologies and standard). So, web services perform business functions such as :
\begin{itemize}
    \item a self-contained business task (for example a funds deposit service)
    \item the whole business process (for example the automated purchasing of office supplies)
    \item an entire application (for example demand forecasts and stock replenishment)
    \item a service-enable resource (for example access to a particular back-end database containing some interesting data).
\end{itemize}
Once we have these functionalities exposed over Internet we can mix and match them to create a complete process. Until the emergence of web service technology the client and server should be on the same web platform (OS or programming language). With web service we can use whatever programming language and operating system that talks each other (i.e. platform independent). When we develop a web service we need to take into account the billing model, i.e. the mode in which the customer can pay in order to use specific functionalities of the service exposed. An \textbf{Application Service Providers (ASP)} is based on the idea to rent its own applications to subscribers such that :
\begin{itemize}
    \item the whole application is developed in terms of user interface, workflow, business and data components that are all bound together to provide a working solution.
    \item an ASP hosts the entire application and the customer has little opportunity to customize it beyond the appearance of the user interface.
    \item an alternative of this is where the ASP is providing a software module that is downloaded to the customer's site on demand (situations in which the software can operate remotely via a browser).
\end{itemize}
When we have an ASP model it offers the whole application suite to the customers, which introduce the concept of software-as-a-service (i.e. pay for the application but we don't own it). This approach has several limitations such as : inability to develop high interactive applications, inability to provide complete customizable application and inability to integrate applications. With Web Services is different because we aren't paying for the whole application, but many different providers offers the functionalities that are needed for someone to develop the software. This is the key difference between ASP and Web Service approach. When we have an ASP, it is able to complete a full fledged application, and then the customer can exploit the application viewing it in the browser. When we have Software-as-a-Service, we have an entire application deployed by the service provider, and this software is downloaded on demand on the customer site and he performs its executed software on his side without accessing a browser. When we have a web service, the idea is that the ASPs offers basic components and then the customer can compose them in order to run on his premise or to have another ASP that composes the services offered by third party. A question to ask ourselves is where are services used ? Typically we have two types of usage :
\begin{itemize}
    \item \textbf{within an enterprise} : web services are intended for being used for enterprise application integration. In this case, they are used to improve the reuse, reduce the skill requirements, can save on infrastructure, deployment and management costs, since we have these components already packed, and can accelerate and reduce the cost of integration as creating new application is simpler than assembling pieces.
    \item \textbf{between enterprises (e-Business integration)} : web services are used to provide services to company's customers, allow to access services from the partners and suppliers of a company. In this case, the fact that web service technology is based on standards, it allows to accelerate the deployment, allow to reduce the technological barriers and to setup common infrastructure, and this dynamicity opens new opportunities.
\end{itemize}
Typically the types of web services are classified in two main categories :
\begin{itemize}
    \item \textbf{Informational services} : they are those services that are relatively simple from the point of view of the computing that they are provided. They simply provides access to some data with less modifications as possible through some application or request-response sequence (e.g. weather report or stock quote info).
    \item \textbf{Complex services} : often they include the composition of other services. In fact, they are services that coordinates a complex application logic and sometimes they involve the invocation of some other external service (e.g. supply-chain application involving order taking, stocking orders, etc).
\end{itemize}
The properties according to which we classify the services are the following :
\begin{itemize}
    \item \textbf{function and non-functional properties} : functional properties are the description of the operational characteristics that define the behavior of the service (i.e. functionality offered by the service). We need also non-functional properties such as the quality of the service, the scalability, availability, etc.
    \item \textbf{Stateless or stateful services} : if we have a stateless service we can invoke it without maintaining the context between the call (e.g. simple informational service). Instead, a stateful service requires their context to be preserved from one invocation to the next (e.g. business processes).
\end{itemize}
An important aspect when we design service is the \textbf{decoupling} and the \textbf{granularity} of the service. Decoupling is a way of measuring the degree of dependency that there is among two systems. Typically, web services are loose coupled, since as they can connect each other through the Internet, we don't need to know too much details of how an application is offered as a service by business partners, because they satisfy standard interfaces, which allows us to know less details as possible. Instead, granularity is a way of measuring how much functionalities are embedded inside the operation. For example simple services are quite discrete, since they typically exhibit normal request and reply mode of operation and are of fine granularity. Complex services are coarse-grained, since they will probably requires a lot of interactions to perform a specific task. Typically, this type of service granularity implies larger and richer data structures (supported by XML).\\\\Another way to comparing services is the \textbf{synchronicity} and \textbf{well-definedness} of the service. Synchronicity means that when we have to design a web service we can follow two programming style : \textbf{synchronous} or \textbf{RPC-style}, with which the client invoke the service as if the operation is a request with a set of arguments and waits for the return that contains the return value (e.g. simple informational services). The second approach is \textbf{asynchronous} or \textbf{document-style}, with which the client when invoke the service it will send as parameters an entire document (e.g. a purchase order). The well-definedness means that the service should be able to describe (WSDL) exactly the rules for interfacing and interacting to other applications. As we said service is the natural evolution of object oriented programming. So, in service oriented computing is well clear the difference between the \textbf{service interface} and \textbf{service implementation}. The first one is the definition of the service functionalities visible to the external world and describe how is possible to access them. It's important that in the service interface to have a description of the characteristics of the interface such as which type of information are available, which are the parameters and data types, etc. The service implementation realize the service interface, hiding to the client the way in which the interface is implemented. Potentially different service providers can use any programming language of their choice to implement the same interface. In a \textbf{service oriented architecture (SOA)} we make a clear distinction between roles :
\begin{itemize}
    \item \textbf{service providers} : they are the organizations that provide the service implementation, supply their service descriptions and provide related technical and business support behind the service.
    \item \textbf{service clients} : they are the end-user organizations that want to use some service.
    \item \textbf{service registry} : it's a kind of searchable directory, where the service provider can publish the service description and the service clients can look for the service they're interested in.
\end{itemize}
As we said when dealing with services, is very important to have the definition also of additional non-functional properties that qualify the service. Typically in a web service environment the usual Quality of Service (QoS) measurement are availability, accessibility, how much the service in conformance to standards, integrity, performance, etc. A \textbf{Service Level Agreement (SLA)} is a kind of contract between the provider and client that formalize all the details of the web service such as contents, price, delivery process, etc. Typically a SLA agreement contains different part such as purpose, parties, validity period, scope, restrictions, penalties, etc. The impact of web service was very high and allowed to converge to a unique set of technologies between business, Enterprise Application Integration, middleware and the web. The main advantages of web service technology are : offers a standard way of exposing legal application as a set of services, represent a standard, easy and flexible way to help overcome application integration issues, allow to develop and assemble applications that are internet-native both for intra enterprise application and extra enterprise application, and they are a way to create cross-enterprise systems with also service-level agreements. The first its disadvantage is the performance, because web service are naturally less performant than traditional middleware. In some scenarios, the transaction management should be managed at the application layer. Another bad point is the lack of business semantics, the dynamicity that they promise somehow should be solved outside the technology landscape. Finally, it's important to have widespread agreement and harmonization, but this implies long processes on standardization.
\subsection{SOAP}
SOAP is an evolution of traditional middleware technology; in fact towards the ends of $90s$ emerged a very interesting way to develop distributed application and in particular modules that were able to communicate over the network according to the RPC interaction paradigm. The background for the evolution of SOAP was \textbf{Inter-Application Communication (IAC)}. Conventional distributed applications uses distributed communication technologies (e.g. Java/RMI, Corba) based on object RPC protocols that was the idea to connect object orientation and network protocols. The basic idea of RPC based on object oriented approach is the fact that you have an identifier used to locate the target object inside the server process. There are some weaknesses such as : both the ends of the communication link needs to be implemented under the same distributed object model, and these protocols are very hard to work over firewalls or proxy servers (for example most firewalls are configured to allow HTTP traffic but not application level protocol like IIOP). So, the idea was that at the beginning of $2000$ to define a new protocols called \textbf{Simple Object Access Protocol (SOAP)}, that was an XML based communication protocol build on top of HTTP in order to be able to overcome firewall complexity. SOAP is a messaging protocol that was used by web services. The objective of SOAP is inter application communication. The idea is that in SOAP the scheme for request and response is coded in XML directly on top of HTTP seen as a transport protocol. We have a service provider, on top of it is running an application object and is equipped with a SOAP-based middleware, which converts procedure calls to/from XML sent through HTTP on the specific programming language and model according to which the servant object is build. On the client side, we have again an application object, which goal is to invoke the operations of the service. Then we have a SOAP-based middleware, to exchange the messages on top of HTTP. In SOAP we can have two communication mechanisms :
\begin{itemize}
    \item \textbf{RPC} : the client will ask for the execution of something and the servant object will reply providing the information of the computing that is requested. In terms of communication style, the web service offers an operation for example for asking the price of a given product. The program accessing to the database answer back by providing the response and providing the price. In particular, it appears as a remote object to a client application. From the point of SOAP we have a SOAP envelope and inside there is a body, which contains the name of operations and the parameters coded in XML. In this case, the client express their request as a method  call with a set of arguments, which returns a response containing a return value.
    \item \textbf{document} : we have that the client ask for a long running operation and therefore instead of executing an action, he's asking for starting a kind of business process and typically sends very complex document. In this case, the body will contain not the coding of a procedure call, but it will transfer on the server side a document (i.e. complex data structure). So, the servant object will typically perform the procedure started by the client and at the end will send out another document that will contain the response.
\end{itemize}
In the SOAP envelope there is also a SOAP header, which is used to extend the usage of the protocol, allowing for example to specify security checksum, transactional context, etc. In SOAP the binding is the definition of how the XML description of the message should be sent using specific transport protocol. The typical binding for SOAP is HTTP. It can use GET and POST. With GET, the request is not a SOAP message but the response is a SOAP message. With POST both request and response are SOAP messages. The error and status code are the same used in HTTP so that HTTP responses can be directly interpreted by a SOAP module. From the point of view of the infrastructure we need an implementation of the client that will implement an application logic that deals with the SOAP engine, the component that will be in charge of coding the request and decoding the response in XML, but we will transmit them to a HTTP engine. SOAP has many advantages like simplicity, portability, firewall friendliness, uses open standards, interoperability and universal acceptance. However it has some disadvantages such as : it relies too much on HTTP (which is stateless) and perform the serialization by value and not by reference (when we have to send information we need to serialize them and send them as a data structure typically coded in XML over  the other side). In addition to SOAP, the basic elements that constitutes a web service are the description language. A service description is needed because in this way the service can be discovered and used by other services and applications. Web service consumers should be able to determine the precise XML interface of a web service. This can be done by leveraging on top of XML schema, but describing some elements :
\begin{itemize}
    \item \textbf{Service description} : it should be machine understandable standards that describe what are the operations offered by the web service and also the wire format and transport protocol that the web service uses to expose his functionality. Finally, we need also to describe a type system that describes the types of parameters that will use in the payload.
\end{itemize}
At this point having a service description in place and a SOAP infrastructure we can have really machine and implementation language-specific elements that allows service requestors and service provider to be independent as each one can discover the other dynamically, and this make the whole system interoperable. This language was called \textbf{Web Service Description Language (WSDL)}, which is a XML-based service representation language used to describe the details of the interfaces exposed by web services and thus means to access the web service. Basically WSDL represents a contract, which is in place the client and servant object. Assume that we have a service provider. It describes in WSDL the contract, i.e. declare which are the specification conditions according to which the clients can use the service, not only at technical level (parameters, type system, etc.) but potentially we can also describe the SLA of my service and other characteristics that we want to enforce. Then the service requestor is able to find in WSDL and he can decide to accept or no the previous contract. Once that he has accepted the contract, he can connect and bind through SOAP to the specific service and therefore is again WSDL that govern this binding and connection via SOAP. In WSDL a contract between a service requestor and provider should specify the following elements :
\begin{itemize}
    \item \textbf{what} a service does, i.e. the operations the service provides.
    \item \textbf{where} it resides, i.e. details of the protocol-specific address.
    \item \textbf{how} to invoke it, i.e. details of the data formats and protocols necessary to access the service's operations.
\end{itemize}
A WSDL document is organized in two different sections :
\begin{itemize}
    \item \textbf{service-interface definition} : it describe the general web service interface structure. This contains all the operations supported by the service, the operation parameters, and abstract data types.
    \item \textbf{service implementation part} : it binds the abstract interface to a concrete network address, to a specific protocol and which concrete data structures are used. In this way the client may really bind to such implementation and to invoke the operations.
\end{itemize}
This enables each part to be defined separately and independently, and reused by other parts. A WSDL document is organized according to the following tags :
\begin{itemize}
    \item $<types>$ : data type definition
    \item $<message>$ : operation parameters
    \item $<operation>$ : actions/operations description that the service provides
    \item $<portType>$ : set of operation definitions
    \item $<binding>$ : operations bindings (i.e. technical mapping of operations on a specific transport protocol)
    \item $<port>$ : it's a concrete endpoint associated with the binding
    \item $<service>$ : it's the real location/address for each binding
    \item $<import>$ : it allows us to reference other XML documents.
\end{itemize}
WSDL defines four main messaging exchange patterns. When we have to interact with a remote module we can use two modes : the sender sends a message to the receiver asking for something, and he does not wait for any response. This is what is called \textbf{one-way message exchange}. Conceptually, we can see it as an invocation of a procedure. Instead, with the second approach, the sender sends a message to the receiver asking for something and he asynchronous wait for a response. This is what is called \textbf{two-way message exchange}. Then in SOAP were proposed other two types of interaction called \textbf{Notification messaging} and \textbf{Solicit messaging}. The first one means that the receiver sends something to the sender and he doesn't expect any response from the sender. Solicit means that the receiver sends something to the sender and he expect a response from the sender like an acknowledgement.
\subsection{Registry and UDDI}
The third element of a web service infrastructure is the registry. In SOAP based services the registry is called \textbf{UDDI}. As we said in SOA we should have these types of interactions : the service provider publish the service and service description, introduce the registration of the requests in a service registry. The service requestor queries for all matching services in the registry on the basis of the needs that he may have. He discover the results, then request the possible service information and the service registry returns the information of the selected service. At this point the service requestor can invoke the requests including possible outputs and achieve the invocation results. The service registry solve an important problem in the infrastructure that is how to find the service that a client wants to use among a large collection of services and providers. \\\\\textbf{Universal Description, Discover, and Integration (UDDI)} was the standard for the definition of the registry in SOAP web service and was at the beginning a real implementation of this description that should supports the web service publishing and discovery processes. In the UDDI philosophy a business should \textbf{describe} its business and its services, \textbf{discover} other businesses that offer desired services and \textbf{integrate} with these other businesses. The design of UDDI is organized in three main components :
\begin{itemize}
    \item \textit{white pages} : it's an entrypoint which gives us the organizational details like the address, the contact and other key points for contacting a person or an organization.
    \item \textit{yellow pages} : it's a way of classifying the business (i.e. the information of the white pages) on the basis of standard taxonomy.
    \item \textit{green pages} : it's represent technical capabilities and information about services (i.e. they can be seen as a manual).
\end{itemize}
Typically UDDI is itself a web service, i.e. it can be accessible through SOAP HTTP. It offer two types of operations : \textbf{inquiry URL} is used by service requestor to requires some information of a web service, and \textbf{publishing URL} is used by the service provider to publish services description and then the WSDL. In UDDI while the white and yellow pages are really offered by UDDI registry, then the green pages aren't stored on the UDDI registry, but are stored as a simple pointer back to the WSDL description in the service provider. Suppose that a service requestor is looking for a service description that contains specific data types in the parameters of an operation. In this case, the UDDI should conceptually enters into each UDDI entry, but in order to be able to filter out which entry really contains the specific data types in the operation definition, it need to retrieve back from each service provider the WSDL file in order to be able to look into it. Technically this means that we need to being a registry and not a repository, to materialize on the fly all the possible service description for each query, and this is very costly, because the information are not stored locally in the service registry, but are stored remotely in the service providers. This is one of the issues that UDDI encountered during its practical application. The UDDI was design as a registry and not as repository, because the design of the registry is very flexible from the point of view of the service provider. The service provider, since it doesn't store in the central registry the technical information is free to update and evolve the service description on the fly without continuously updating back in the UDDI service description. One of the drawbacks of UDDI, is that it's really service provider oriented, but not service requestor oriented.
\subsection{RESTful}
A service mash-up is a web application that combines data from one or more sources (e.g. open APIs) into a single integrated tool. The difference with SOAP web services is that the way of building the application is completely different. This approach is based on several technologies such as SOAP, RESTful and Atom/RSS. The RESTful web services started to emerge toward the end of $2000$ and they started to be considered as an alternative to WSDL for SOAP based web service. In order to compare the two approaches is important to analyze what are conceptually their differences. Typically, when dealing with web services is common to classify the possible standards that are build on top of web services in four different layers :
\begin{itemize}
    \item \textbf{Messaging} : how a client and servant can interact.
    \item \textbf{Single service} : what are the standards and technologies that helps to develop and to describe single services.
    \item \textbf{Multiple interacting services} : what are the technologies and services that deals with the composition and orchestration of multiple services.
    \item \textbf{Registry/Repository and discovery} : it deals with registry or repository, and possible discovery of services.
\end{itemize}
Conversely, in RESTful based services with don't have the last two layers. REST is not really a technology, but it's an architectural approach. It's a kind of methods in which by adopting specific conventions to use the technology we can achieve the results we may be interested in. The idea of REST is that we can transmit data directly over HTTP without including any additional layers as SOAP. A traditional web page is consumed by a user through a web browser. Why can't we consume a web page through a program ? We can do that, but this requires a style of building this infrastructure (the REST one), since the information from a web page should be extracted and returned to the client. We know that in HTTP we have basic verbs such as GET, POST, UPDATE and DELETE. RESTful web services are based on the concept of these HTTP verbs, and the resources will represents the states of required data items, i.e. their values. REST is a kind of RPC, but the idea is that it isn't a RPC system in which is the developer that each time through the definition of the service interface defines the name and the semantics of the methods. Instead, it's a RPC system in which the methods has been already defined in advance, and the developer have only to associate to this predefined methods (CRUD operations) the resources the methods may wants to access. The RESTful basic principles are the following :
\begin{itemize}
    \item \textbf{Addressability} : it means every resource should have an URL.
    \item \textbf{Uniform interface} : we already said that, all the services have the same interface, which is based on the HTTP verbs.
    \item \textbf{Stateless interaction} : there isn't any concept of session (i.e. each interaction is stateless). We access the resource and read it.
    \item \textbf{Self-describing messages} : it means that the message are self-describing, because they are part of HTTP.
    \item \textbf{Hypermedia} : they are just another type of link.
\end{itemize}
REST is incompatible with endpoint, because the resources are provided through URLs. Instead, in RPC we can either address data objects (REST does this one) or software components (endpoint RPC does this one). In REST there exists three different levels of the maturity of the API, where :
\begin{enumerate}
    \item \textbf{HTTP as a tunnel} : REST just using HTTP as a way to do RPC, but we really don't model in the proper way.
    \item \textbf{Resources} : when we correctly identifies all the resources of our application and access them through HTTP.
    \item \textbf{HTTP verbs} : we correctly adopt the HTTP verbs.
    \item \textbf{Hypermedia} : we are addressing in the proper way also hypermedia content.
\end{enumerate}
RESTful was considered so trendy because it's easy and lightweight, and starting from $2010$ the big companies like Amazon, Yahoo and Google started to offer their web services as RESTful.
